
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    // Check if a user document exists for the given UID
    function userDocumentExists(uid) {
      return exists(/databases/$(database)/documents/users/$(uid));
    }

    // Get user data (CALLER MUST ENSURE DOCUMENT EXISTS FIRST using userDocumentExists(uid))
    // It's safer for functions used in conditions to return boolean or check existence internally.
    // This function is for internal use by other helpers that check existence first.
    function getUserDocumentDataUnsafe(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    // Check if the currently logged-in user is a superadmin
    function isRequesterSuperadmin() {
      return isSignedIn() &&
             userDocumentExists(request.auth.uid) &&
             getUserDocumentDataUnsafe(request.auth.uid).role == 'superadmin';
    }

    // Check if the currently logged-in user has the role 'admin'
    function isRequesterAdmin() {
      return isSignedIn() &&
             userDocumentExists(request.auth.uid) &&
             getUserDocumentDataUnsafe(request.auth.uid).role == 'admin';
    }
    
    // Get the merchantId of the currently logged-in user (assumes userDoc exists and has merchantId)
    // Callers should ensure isRequesterAdmin() or similar is true first.
    function getRequesterMerchantIdUnsafe() {
        return getUserDocumentDataUnsafe(request.auth.uid).merchantId;
    }


    // --- Global Rule for Superadmin (broad access) ---
    // This rule gives superadmins full read/write access to everything.
    match /{document=**} {
      allow read, write: if isRequesterSuperadmin();
    }

    // --- Rules for /users collection ---
    match /users/{userId} {
      // Document being read/written is owned by the requester
      function isOwner() {
        return isSignedIn() && request.auth.uid == userId;
      }

      // Requester is an admin of the merchant that the target user document (resource.data) belongs to
      function isRequesterAdminOfTargetUserMerchant() {
        return resource.data != null && resource.data.merchantId != null && // Check existing doc
               isRequesterAdmin() && 
               userDocumentExists(request.auth.uid) && // Ensure admin doc has merchantId
               getRequesterMerchantIdUnsafe() == resource.data.merchantId;
      }
      
      // New user registration: creating their own 'admin' account for a new merchant
      function isSelfRegisteringMerchantAdmin() {
        return isSignedIn() &&
               request.auth.uid == userId && // User is creating their own document
               request.resource.data.role == 'admin' &&
               request.resource.data.status == 'pending_approval' &&
               request.resource.data.merchantId == request.auth.uid; // Merchant ID is their own UID
      }

      // Admin creating a kasir. As per new requirement, any admin can create a kasir.
      // The client will set the kasir's merchantId.
      function isAdminCreatingKasir() {
        return isRequesterAdmin() && // Requester must be an admin
               request.resource.data.role == 'kasir'; // New document must be for a kasir
      }
      
      // Superadmin creating an admin user
      function isSuperadminCreatingAdmin() {
        return isRequesterSuperadmin() &&
               request.resource.data.role == 'admin' &&
               request.resource.data.status == 'active';
      }

      allow read: if isOwner() || isRequesterAdminOfTargetUserMerchant() || isRequesterSuperadmin();

      allow create: if isSelfRegisteringMerchantAdmin() || 
                       isAdminCreatingKasir() || 
                       isSuperadminCreatingAdmin();

      allow update: if isOwner() || isRequesterAdminOfTargetUserMerchant() || isRequesterSuperadmin();

      function isSuperadminDeletingOtherUser() {
        return isRequesterSuperadmin() && userId != request.auth.uid;
      }
      function isAdminDeletingKasirFromOwnMerchant() {
        return isRequesterAdmin() &&
               resource.data != null && 
               resource.data.role == 'kasir' &&
               userDocumentExists(request.auth.uid) && 
               getRequesterMerchantIdUnsafe() == resource.data.merchantId;
      }
      allow delete: if isSuperadminDeletingOtherUser() || isAdminDeletingKasirFromOwnMerchant();
    }

    // --- Rules for /outlets collection ---
    match /outlets/{outletId} {
      function isOutletOfRequesterMerchant() {
        return resource.data != null &&
               resource.data.merchantId != null &&
               isRequesterAdmin() && 
               userDocumentExists(request.auth.uid) && 
               getRequesterMerchantIdUnsafe() == resource.data.merchantId;
      }
      
      function isAdminCreatingOutletForOwnMerchant() {
        return isRequesterAdmin() &&
               userDocumentExists(request.auth.uid) && 
               request.resource.data.merchantId == getRequesterMerchantIdUnsafe();
      }

      allow read: if isRequesterAdmin() && isOutletOfRequesterMerchant();
      allow create: if isAdminCreatingOutletForOwnMerchant();
      allow update, delete: if isOutletOfRequesterMerchant();
    }

    // --- Rules for /products collection ---
    match /products/{productId} {
      function isProductOfRequesterMerchant() {
         return resource.data != null &&
               resource.data.merchantId != null &&
               isSignedIn() && userDocumentExists(request.auth.uid) &&
               (getUserDocumentDataUnsafe(request.auth.uid).role == 'admin' || getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir') &&
               getRequesterMerchantIdUnsafe() == resource.data.merchantId;
      }
      function isAdminCreatingProductForOwnMerchant() {
        return isRequesterAdmin() &&
               userDocumentExists(request.auth.uid) &&
               request.resource.data.merchantId == getRequesterMerchantIdUnsafe();
      }
      function isKasirUpdatingStockForOwnMerchantProduct() {
        return isSignedIn() && 
               userDocumentExists(request.auth.uid) && 
               getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir' &&
               resource.data != null && 
               resource.data.merchantId == getRequesterMerchantIdUnsafe() && 
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['units', 'updatedAt']);
      }

      allow read: if isSignedIn() && userDocumentExists(request.auth.uid) && (getUserDocumentDataUnsafe(request.auth.uid).role == 'admin' || getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir') && isProductOfRequesterMerchant();
      allow create: if isAdminCreatingProductForOwnMerchant();
      allow update: if (isRequesterAdmin() && isProductOfRequesterMerchant()) || isKasirUpdatingStockForOwnMerchantProduct();
      allow delete: if isRequesterAdmin() && isProductOfRequesterMerchant();
    }

    // --- Rules for /suppliers collection ---
    match /suppliers/{supplierId} {
      function isSupplierOfRequesterMerchant() {
         return resource.data != null &&
               resource.data.merchantId != null &&
               isRequesterAdmin() &&
               userDocumentExists(request.auth.uid) &&
               getRequesterMerchantIdUnsafe() == resource.data.merchantId;
      }
      function isAdminCreatingSupplierForOwnMerchant() {
        return isRequesterAdmin() &&
               userDocumentExists(request.auth.uid) &&
               request.resource.data.merchantId == getRequesterMerchantIdUnsafe();
      }

      allow read: if isSupplierOfRequesterMerchant();
      allow create: if isAdminCreatingSupplierForOwnMerchant();
      allow update, delete: if isSupplierOfRequesterMerchant();
    }

    // --- Rules for /settings collection ---
    // Document ID for settings is assumed to be the merchantId
    match /settings/{settingsMerchantId} {
      function isAccessingOwnMerchantSettings() {
        return isRequesterAdmin() &&
               userDocumentExists(request.auth.uid) &&
               getRequesterMerchantIdUnsafe() == settingsMerchantId;
      }
      allow read, write: if isAccessingOwnMerchantSettings();
    }

    // --- Rules for /transactions collection ---
    match /transactions/{transactionId} {
      function canRequesterCreateOrReadTransaction() {
          // This function checks if the requester is an admin or kasir AND
          // if their merchantId matches the transaction's merchantId.
          // For create, it checks request.resource.data. For read, it checks resource.data.
          let isWriteOperation = request.method == 'create' || request.method == 'update' || request.method == 'delete';
          let transactionMerchantId = isWriteOperation ? request.resource.data.merchantId : resource.data.merchantId;
          
          return isSignedIn() &&
                 userDocumentExists(request.auth.uid) &&
                 (getUserDocumentDataUnsafe(request.auth.uid).role == 'admin' || getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir') &&
                 userDocumentExists(request.auth.uid) && // Redundant check, but safe
                 getRequesterMerchantIdUnsafe() == transactionMerchantId;
      }
      
      function isKasirOperatingAssignedOutletForCreate() {
          // This function assumes canRequesterCreateOrReadTransaction has verified role and merchant match.
          // It further refines for kasir to only create for their assigned outlets.
          // This should only be called if the requester is a kasir.
          return getUserDocumentDataUnsafe(request.auth.uid).outlets != null && // Kasir must have outlets field
                 request.resource.data.outletId in getUserDocumentDataUnsafe(request.auth.uid).outlets;
      }
      
      allow create: if canRequesterCreateOrReadTransaction() &&
                       (isRequesterAdmin() || isKasirOperatingAssignedOutletForCreate()); // Admin OR (Kasir AND assigned to outlet)
                       
      allow read: if resource.data != null && canRequesterCreateOrReadTransaction(); // Ensure doc exists for read
      // Update/Delete for transactions are typically not allowed or highly restricted.
    }
  }
}

    