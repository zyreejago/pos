
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function userDocumentExists(uid) {
      return exists(/databases/$(database)/documents/users/$(uid));
    }

    // WARNING: Unsafe. Call only after userDocumentExists(uid) is true.
    function getUserDocumentDataUnsafe(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    function userDocumentHasRole(uid, targetRole) {
      // Assumes userDocumentExists(uid) has been checked by caller if needed.
      let userData = getUserDocumentDataUnsafe(uid);
      return userData.role == targetRole;
    }

    // --- Requester Status Functions ---
    function isRequesterSuperadmin() {
      return isSignedIn() &&
             userDocumentExists(request.auth.uid) &&
             userDocumentHasRole(request.auth.uid, 'superadmin');
    }

    // Checks if the requester is an admin AND has a merchantId set in their document.
    function isRequesterAdminWithMerchantContext() {
      if (!isSignedIn() || !userDocumentExists(request.auth.uid)) {
        return false;
      }
      let adminData = getUserDocumentDataUnsafe(request.auth.uid); // Safe due to userDocumentExists check
      return adminData.role == 'admin' && adminData.merchantId != null;
    }

    // WARNING: Unsafe. Call only after isRequesterAdminWithMerchantContext() is true.
    function getRequesterAdminMerchantIdUnsafe() {
        return getUserDocumentDataUnsafe(request.auth.uid).merchantId;
    }

    // --- Specific Action Checks ---
    function isAdminCreatingKasirForOwnMerchant() {
      // 1. Requester must be an admin with a valid merchant context.
      if (!isRequesterAdminWithMerchantContext()) {
        return false;
      }
      // 2. The new document (kasir) must have role 'kasir'.
      if (request.resource.data.role != 'kasir') {
        return false;
      }
      // 3. The new kasir's merchantId must match the creating admin's merchantId.
      //    Client (KasirTable.tsx) sets newKasir.merchantId = admin.merchantId.
      //    This rule verifies that consistency.
      let adminMerchantId = getRequesterAdminMerchantIdUnsafe(); // Safe due to isRequesterAdminWithMerchantContext
      return request.resource.data.merchantId == adminMerchantId;
    }

    function isSuperadminCreatingAdminUser() {
      // Superadmin creating a new user who will be an admin.
      return isRequesterSuperadmin() &&
             request.resource.data.role == 'admin' &&
             request.resource.data.status == 'active'; // Example: superadmin creates active admins
    }

    function isSelfRegisteringAsMerchantAdmin() {
      // User creating their own document upon registration as a new merchant admin.
      return request.auth.uid == userId && // userId is the path parameter for /users/{userId}
             request.resource.data.role == 'admin' &&
             request.resource.data.status == 'pending_approval' && // New merchants start as pending
             request.resource.data.merchantId == request.auth.uid;  // Their merchantId is initially their own UID
    }

    // --- Global Rule for Superadmin ---
    // Superadmin has full read/write access to all documents.
    match /{document=**} {
      allow read, write: if isRequesterSuperadmin();
    }

    // --- Collection: users ---
    match /users/{userId} {
      // Document owner can always read and update their own data.
      allow read, update: if isSignedIn() && request.auth.uid == userId;

      // Admin can read/update users (kasirs) belonging to their own merchant.
      allow read, update: if isRequesterAdminWithMerchantContext() &&
                             userDocumentExists(userId) && // Target user document exists
                             getUserDocumentDataUnsafe(userId).merchantId == getRequesterAdminMerchantIdUnsafe();


      allow create: if isAdminCreatingKasirForOwnMerchant() ||
                       isSuperadminCreatingAdminUser() ||
                       isSelfRegisteringAsMerchantAdmin();

      // Admin can delete kasirs of their own merchant. Superadmin can delete non-superadmins.
      allow delete: if (isRequesterAdminWithMerchantContext() &&
                        userDocumentExists(userId) &&
                        userDocumentHasRole(userId, 'kasir') &&
                        getUserDocumentDataUnsafe(userId).merchantId == getRequesterAdminMerchantIdUnsafe()) ||
                       (isRequesterSuperadmin() && userDocumentExists(userId) && !userDocumentHasRole(userId, 'superadmin'));
    }

    // --- Collection: outlets ---
    match /outlets/{outletId} {
      function isOutletOfRequesterMerchant() {
        if(!isRequesterAdminWithMerchantContext()) { return false; }
        return resource.data.merchantId == getRequesterAdminMerchantIdUnsafe();
      }
      function isNewOutletForRequesterMerchant() {
        if(!isRequesterAdminWithMerchantContext()) { return false; }
        return request.resource.data.merchantId == getRequesterAdminMerchantIdUnsafe();
      }

      allow read: if isRequesterAdminWithMerchantContext() && isOutletOfRequesterMerchant();
      allow create: if isRequesterAdminWithMerchantContext() && isNewOutletForRequesterMerchant();
      allow update, delete: if isRequesterAdminWithMerchantContext() && isOutletOfRequesterMerchant();
    }

    // --- Collection: products ---
    match /products/{productId} {
      function isProductOfRequesterMerchant() {
        // Works for admin or kasir, as long as they have a merchant context.
        if (!isSignedIn() || !userDocumentExists(request.auth.uid)) { return false; }
        let requesterData = getUserDocumentDataUnsafe(request.auth.uid);
        if (requesterData.merchantId == null) { return false; }
        return resource.data.merchantId == requesterData.merchantId;
      }
       function isNewProductForRequesterMerchant() {
        if(!isRequesterAdminWithMerchantContext()) { return false; } // Only admins create products
        return request.resource.data.merchantId == getRequesterAdminMerchantIdUnsafe();
      }

      // Admin or Kasir can read products of their merchant.
      allow read: if (isRequesterAdminWithMerchantContext() || (isSignedIn() && userDocumentExists(request.auth.uid) && getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir')) &&
                     isProductOfRequesterMerchant();

      allow create: if isRequesterAdminWithMerchantContext() && isNewProductForRequesterMerchant();

      // Admin can update any product of their merchant.
      // Kasir can only update stock (units field) of products of their merchant.
      allow update: if (isRequesterAdminWithMerchantContext() && isProductOfRequesterMerchant()) ||
                       (isSignedIn() && userDocumentExists(request.auth.uid) && getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir' &&
                        isProductOfRequesterMerchant() &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['units']));

      allow delete: if isRequesterAdminWithMerchantContext() && isProductOfRequesterMerchant();
    }

    // --- Collection: suppliers ---
    match /suppliers/{supplierId} {
      function isSupplierOfRequesterMerchant() {
        if(!isRequesterAdminWithMerchantContext()) { return false; }
        return resource.data.merchantId == getRequesterAdminMerchantIdUnsafe();
      }
      function isNewSupplierForRequesterMerchant() {
        if(!isRequesterAdminWithMerchantContext()) { return false; }
        return request.resource.data.merchantId == getRequesterAdminMerchantIdUnsafe();
      }
      allow read, create, update, delete: if isRequesterAdminWithMerchantContext() &&
                                             (request.method == 'get' || request.method == 'list' ? isSupplierOfRequesterMerchant() : isNewSupplierForRequesterMerchant());
    }

    // --- Collection: settings ---
    match /settings/{settingsMerchantId} {
      allow read, write: if isRequesterAdminWithMerchantContext() &&
                            getRequesterAdminMerchantIdUnsafe() == settingsMerchantId;
    }

    // --- Collection: transactions ---
    match /transactions/{transactionId} {
      function isTransactionValidForCreator() {
        if (!isSignedIn() || !userDocumentExists(request.auth.uid)) {
          return false;
        }
        let creatorData = getUserDocumentDataUnsafe(request.auth.uid);
        // Creator must be an admin or kasir
        if (creatorData.role != 'admin' && creatorData.role != 'kasir') {
          return false;
        }
        // Creator must belong to the merchant of the transaction
        if (creatorData.merchantId != request.resource.data.merchantId) {
          return false;
        }
        // If creator is a kasir, they must have access to the outlet of the transaction
        if (creatorData.role == 'kasir') {
          if (creatorData.outlets == null || !(request.resource.data.outletId in creatorData.outlets)) {
            // Correction: 'in' operator for lists checks if index exists. For array contains, use .hasAny() or loop.
            // For simplicity, if outlets is an array of IDs:
            // This part needs careful implementation based on how 'outlets' is stored.
            // Assuming creatorData.outlets is an array of outlet IDs:
            // return request.resource.data.outletId in creatorData.outlets; // This is for maps/objects
            // A better way for arrays if you can't use hasAny (which is v2):
            // Firestore rules don't have a direct "array contains value" for arrays of strings easily.
            // A common workaround is storing accessible outlets as a map: outlets: {'outletId1': true, 'outletId2': true}
            // If creatorData.outlets is a map like {'outlet_id_1': true, 'outlet_id_2': true}
             if (creatorData.outlets == null || !creatorData.outlets[request.resource.data.outletId]) {
               return false;
             }
          }
        }
        return true; // All checks passed
      }

      allow create: if isTransactionValidForCreator();

      // Admin or Kasir can read transactions of their merchant.
      allow read: if (isRequesterAdminWithMerchantContext() || (isSignedIn() && userDocumentExists(request.auth.uid) && getUserDocumentDataUnsafe(request.auth.uid).role == 'kasir')) &&
                     resource.data.merchantId == getUserDocumentDataUnsafe(request.auth.uid).merchantId;
    }
  }
}

    